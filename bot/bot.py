import configparser
import json
import asyncio
import random
import re
import os
from os import path

import aiohttp
from aiogram import Bot, Dispatcher, executor, types
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.utils.exceptions import ChatNotFound
from loguru import logger

config = configparser.ConfigParser()
config.read(path.join(path.dirname(path.abspath(__file__)), 'config.ini'))
URL = config['Django']['url']
API_TOKEN = config['Telegram']['token']

bot = Bot(token=API_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)

news_filters = ['–ò–¢', '–î–∏–∑–∞–π–Ω', '–ë–∏–∑–Ω–µ—Å', '–ò–≥—Ä—ã', '–ù–æ–≤–æ—Å—Ç–∏', "–ë–ª–æ–≥–∏", "–ü—Ä–æ–¥–∞–∂–∏", "–ú—É–∑—ã–∫–∞","–ü–æ–∑–Ω–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ", "–¶–∏—Ç–∞—Ç—ã"]
user_filters = {}
user_history = {}
markup_button = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
itembtn1 = types.KeyboardButton('–ò–∑–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã')
itembtn2 = types.KeyboardButton('–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–≤–æ—Å—Ç–∏')
markup_button.add(itembtn1, itembtn2)


async def get_channel(text: str):
    pattern = r'https:\/\/t\.me\/(.+)'
    if text.startswith('@'):
        channel = text
        return channel
    elif re.match(pattern, text):
        result = re.match(pattern, text)
        channel = f"@{result.group(1)}"
        return channel
    else:
        return None


# States
class SubscribeForm(StatesGroup):
    channel = State()


class UnsubscribeForm(StatesGroup):
    channel = State()


@dp.message_handler(commands=['start'])
async def start(message):
    '''–ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'''
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ö–æ–¥–∏–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É
    async with aiohttp.ClientSession() as session:
        async with session.get(f'{URL}/api/user/{user_id}') as response:
            if response.status == 200:
                user = await response.json()
                text = ('–í—ã —É–∂–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫—É!\n–î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–æ–π: /changefilters')
                await bot.send_message(message.chat.id, text)
                return await send_news(user)

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É
    markup = types.InlineKeyboardMarkup(row_width=3)
    num_pages = len(news_filters) % 8

    for _filter in news_filters:
        markup.row(types.InlineKeyboardButton(_filter, callback_data=_filter))

    markup.row(
        types.InlineKeyboardButton('–ù–∞–∑–∞–¥', callback_data='previous_filters'),
        types.InlineKeyboardButton(f'1/{num_pages}', callback_data='page_count'),
        types.InlineKeyboardButton('–î–∞–ª–µ–µ', callback_data='next_filters')
    )
    markup.add(types.InlineKeyboardButton('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å', callback_data='complete'))
    text = (
        '–ü—Ä–∏–≤–µ—Ç! –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–æ–≤ –≤ Telegram? –°–ª–æ–∂–Ω–æ —ç—Ç–æ –≤—Å—ë —á–∏—Ç–∞—Ç—å, –ø–æ–Ω–∏–º–∞—é. '
        '–Ø —Ç—É—Ç, –∫—Å—Ç–∞—Ç–∏ –∫–∞–∫ —Ä–∞–∑ –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –ø–æ–º–æ—á—å —Ç–µ–±–µ –≤ —ç—Ç–æ–º. –î–∞–≤–∞–π –æ–ø—Ä–µ–¥–µ–ª–∏–º—Å—è —Å —Ç–≤–æ–∏–º–∏ –≤–∫—É—Å–∞–º–∏. '
        '–í—ã–±–∏—Ä–∞–π, —á—Ç–æ —Ç–µ–±–µ –Ω—Ä–∞–≤–∏—Ç—Å—è (–∫–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—à—å—Å—è, –Ω–∞–∂–º–∏ ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª):'
    )
    await bot.send_message(message.chat.id, text, reply_markup=markup)


@dp.message_handler(commands=['help'])
async def help(message):
    text = (
        '–¢—ã –º–æ–∂–µ—à—å –Ω–∞–ø–∏—Å–∞—Ç—å –º–Ω–µ: /changefilters ‚Äî —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º –∏ –ø–æ–ø—Ä–∞–≤–∏—Ç—å –∏—Ö. '
        '–ö–∞–∫ —Å—Ç–æ–ª—å–∫–æ —Ç—ã —Å—Ç–∞–≤–∏—à—å ‚ù§ –∏–ª–∏ üëéüèª –ø–æ—Å–ª–µ–¥–Ω–µ–º—É –ø–æ—Å—Ç—É, —è –æ—Ç–ø—Ä–∞–≤–ª—è—é —Ç–µ–±–µ –Ω–æ–≤—ã–π.'
    )
    await bot.send_message(message.chat.id, text)


@dp.callback_query_handler(lambda call: call.data in news_filters)
async def filter_click_inline(call):
    '''–°–æ–±–∏—Ä–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'''
    choosen_filter = call.data
    user_id = call.from_user.id
    chat_id = call.message.chat.id
    message_id = call.message.message_id

    try:
        existing_filters = user_filters[user_id]
    except KeyError:
        event_type = 'append'
        user_filters[user_id] = [choosen_filter]
    else:
        if choosen_filter in existing_filters:
            event_type = 'remove'
            existing_filters.remove(choosen_filter)
        else:
            event_type = 'append'
            existing_filters.append(choosen_filter)
        user_filters[user_id] = existing_filters

    markup = call.message.reply_markup
    for i, row in enumerate(markup.inline_keyboard):
        try:
            filter_button = next(btn for btn in row if btn.callback_data == choosen_filter)
            btn_index = row.index(filter_button)
        except StopIteration:
            continue
        else:
            if event_type == 'append':
                filter_button.text = f'{choosen_filter} ‚úÖ'
            elif event_type == 'remove':
                filter_button.text = choosen_filter
            row[btn_index] = filter_button
            markup.inline_keyboard[i] = row
            break

    await bot.edit_message_reply_markup(
        chat_id=chat_id,
        message_id=message_id,
        reply_markup=markup
    )


@dp.callback_query_handler(lambda call: call.data == 'complete')
async def complete_click_inline(call):
    '''–°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –µ–≥–æ —Ñ–∏–ª—å—Ç—Ä—ã –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö'''
    user_id = call.from_user.id
    chat_id = call.message.chat.id
    message_id = call.message.message_id

    if not user_filters.get(user_id):
        return await bot.answer_callback_query(call.id, '–í–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–∞ –≤—ã–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é!')

    data = {
        'id': user_id,
        'filters': user_filters[user_id]
    }

    async with aiohttp.ClientSession() as session:
        response = session.post(url=f'{URL}/api/user/', json=data)
    if response.status == 201:
        await bot.answer_callback_query(call.id, '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!')
        await bot.delete_message(chat_id, message_id)
        text = (
            '–û—Ç–ª–∏—á–Ω–æ, –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –∑–∞–¥–∞–Ω—ã! –¢–∞–∫ —è –±—É–¥—É –ª—É—á—à–µ –ø–æ–Ω–∏–º–∞—Ç—å —Ç–µ–±—è. '
            '–¢–µ–ø–µ—Ä—å, —è –±—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —Ç–µ–±–µ –ø–æ—Å—Ç—ã, –∞ —Ç—ã –∏—Ö –æ—Ü–µ–Ω–∏–≤–∞—Ç—å, —è –ø—Ä–∏—Å—ã–ª–∞—Ç—å, –∞ —Ç—ã –æ—Ü–µ–Ω–∏–≤–∞—Ç—å, —è –ø—Ä–∏—Å—ã–ª–∞—Ç—å... –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ. '
            '–ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –ø—Ä–æ–±–ª–µ–º—ã, —Ç—ã –≤—Å–µ–≥–¥–∞ –º–æ–∂–µ—à—å –∑–∞—Ä—É—á–∏—Ç—å—Å—è –º–æ–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π, –Ω–∞–ø–∏—Å–∞–≤ /help'
        )
        await bot.send_message(call.from_user.id, text)
        await send_news(call)


@dp.callback_query_handler(lambda call: call.data.startswith('like'))
async def on_like(call):
    user_id = call.from_user.id
    message_id = call.message.message_id
    channel_id = call.data.split('_')[1]
    data = {
        'user_id': user_id,
        'message_id':message_id,
        'channel_id': channel_id,
        'rate': True
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url=f'{URL}/api/rate/', json=data) as response:
            if response.status != 201:
                return logger.error(await response.text())
        async with session.get(url=f'{URL}/api/user/{user_id}') as response:
            if response.status == 200:
                user = await response.json()
            else:
                return logger.error(await response.text())
    
    await send_news(user)


@dp.callback_query_handler(lambda call: call.data.startswith('nolike'))
async def on_nolike(call):
    user_id = call.from_user.id
    message_id = call.message.message_id
    channel_id = call.data.split('_')[1]
    data = {
        'user_id': user_id,
        'message_id':message_id,
        'channel_id': channel_id,
        'rate': False
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(url=f'{URL}/api/rate/', json=data) as response:
            if response.status != 201:
                return logger.error(await response.text())
        async with session.get(url=f'{URL}/api/user/{user_id}') as response:
            if response.status == 200:
                user = await response.json()
            else:
                return logger.error(await response.text())
    
    await send_news(user)


@dp.callback_query_handler(lambda call: call.data == 'next')
async def next_news(call):
    user_id = call.from_user.id
    async with aiohttp.ClientSession() as session:
        async with session.get(url=f'{URL}/api/user/{user_id}') as response:
            if response.status == 200:
                user = await response.json()
    await send_news(user)


@dp.message_handler(commands=['news'])
async def send_new(message):
    user_id = message.from_user.id
    async with aiohttp.ClientSession() as session:
        async with session.get(url=f'{URL}/api/user/{user_id}') as response:
            if response.status == 200:
                user = await response.json()
    await send_news(user)


@dp.message_handler(commands=['changefilters'])
async def change_filters(message):
    '''–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'''
    user_id = message.from_user.id
    chat_id = message.chat.id

    # –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    try:
        existing_filters = user_filters[user_id]
    except KeyError:
        async with aiohttp.ClientSession() as session:
            async with session.get(url=f'{URL}/api/user/{user_id}') as response:
                if response.status == 200:
                    existing_filters = (await response.json())['filters']
                    user_filters[user_id] = existing_filters
                elif response.status == 404:
                    return await bot.send_message(
                        chat_id=chat_id, 
                        text='–í—ã –µ—â—ë –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫—É! –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–æ–π /start'
                    )
                else:
                    return logger.error(await response.text())

    markup = types.InlineKeyboardMarkup()
    buttons = []
    i = 0
    num_pages = len(news_filters) % 8

    for _filter in news_filters[:8]:
        if _filter in existing_filters:
            i+=1
            buttons.append(types.InlineKeyboardButton(text=f'{_filter} ‚úÖ', callback_data=_filter))
        else:
            i+=1
            buttons.append(types.InlineKeyboardButton(text=_filter, callback_data=_filter))
        if i == 2:
            i = 0
            markup.row(*buttons)
            buttons = []
    markup.row(
        types.InlineKeyboardButton('–ù–∞–∑–∞–¥', callback_data='previous_filters'),
        types.InlineKeyboardButton(f'1/{num_pages}', callback_data='page_count'),
        types.InlineKeyboardButton('–î–∞–ª–µ–µ', callback_data='next_filters')
    )
    markup.add(types.InlineKeyboardButton('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å', callback_data='changefilters'))

    await bot.send_message(chat_id, '–ò–∑–º–µ–Ω–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏', reply_markup=markup)


@dp.callback_query_handler(lambda call: call.data in ('previous_filters', 'next_filters'))
async def on_nav_filters_click_inline(call):
    user_id = call.from_user.id
    chat_id = call.message.chat.id
    message_id = call.message.message_id

    save_btn = call.message.reply_markup.inline_keyboard[-1][0]
    nav_buttons = call.message.reply_markup.inline_keyboard[-2]
    num_pages_btn = nav_buttons[1]
    current_page, count_pages = map(int, num_pages_btn.text.split('/'))

    if current_page == count_pages and call.data == 'next_filters':
        return
    elif current_page == 1 and call.data == 'previous_filters':
        return

    if call.data == 'previous_filters':
        next_page = current_page - 1
    else:
        next_page = current_page + 1
    num_pages_btn.text = f'{next_page}/{count_pages}'
    nav_buttons[1] = num_pages_btn

    # –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    try:
        existing_filters = user_filters[user_id]
    except KeyError:
        async with aiohttp.ClientSession() as session:
            async with session.get(url=f'{URL}/api/user/{user_id}') as response:
                if response.status == 200:
                    existing_filters = (await response.json())['filters']
                else:
                    return logger.error(await response.text())

    markup = types.InlineKeyboardMarkup()
    buttons = []
    i = 0
    start_index = current_page * 8
    if next_page == 1:
        start_index = 0
    stop_index = next_page * 8

    for _filter in news_filters[start_index:stop_index]:
        if _filter in existing_filters:
            i+=1
            buttons.append(types.InlineKeyboardButton(text=f'{_filter} ‚úÖ', callback_data=_filter))
        else:
            i+=1
            buttons.append(types.InlineKeyboardButton(text=_filter, callback_data=_filter))
        if i == 2:
            i = 0
            markup.row(*buttons)
            buttons = []
    markup.row(*nav_buttons)
    markup.add(save_btn)

    await bot.edit_message_reply_markup(chat_id=chat_id, message_id=message_id, reply_markup=markup)


@dp.callback_query_handler(lambda call: call.data == 'changefilters')
async def change_filters_click_inline(call):
    user_id = call.from_user.id
    chat_id = call.message.chat.id
    message_id = call.message.message_id

    if not user_filters.get(user_id):
        return await bot.answer_callback_query(call.id, '–í–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é!')

    data = {
        'id': user_id,
        'filters': user_filters[user_id]
    }

    async with aiohttp.ClientSession() as session:
        async with session.put(url=f'{URL}/api/user/', json=data) as response:
            if response.status == 200:
                user = await response.json()
            else:
                return logger.error(await response.text())

    await bot.answer_callback_query(call.id, text='–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω—ã!')
    await bot.delete_message(chat_id, message_id)

    await send_news(user)


@dp.message_handler(content_types=["text"])
async def on_message(message):
    if message.text == "–ò–∑–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã":
        await change_filters(message)
    if message.text == "–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–≤–æ—Å—Ç–∏":
        await send_new(message)
    user_id = message.from_user.id
    if message.text != "–ü–æ–ª—É—á–∏—Ç—å –Ω–æ–≤–æ—Å—Ç–∏" and message.text != "–ò–∑–º–µ–Ω–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã":
        await bot.send_message(user_id,"–°–µ–π—á–∞—Å —è –æ—Ç–ø—Ä–∞–≤–ª—è—é –Ω–æ–≤–æ—Å—Ç–∏, –∞ –≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–≤—Ç—Ä–∞ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é –º–∏—Ä :)", reply_markup=markup_button)


@dp.message_handler(commands=['subscribes'])
async def subscribes(message):
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ö–æ–¥–∏–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É
    async with aiohttp.ClientSession() as session:
        async with session.get(f'{URL}/api/user/{user_id}') as response:
            if response.status != 200:
                text = "–í—ã –µ—â—ë –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫—É.\n–í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–æ–º–∞–Ω–¥–æ–π: /start"
                return await bot.send_message(message.chat.id, text)
    
    markup = types.InlineKeyboardMarkup()
    markup.row(
        types.InlineKeyboardButton('–î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª', callback_data='subscribe'),
        types.InlineKeyboardButton('–£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª', callback_data='unsubscribe')
    )

    await bot.send_message(message.chat.id, '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ', reply_markup=markup)


@dp.callback_query_handler(lambda call: call.data == 'subscribe')
async def subscribe_click_inline(call):
    # Set state
    await SubscribeForm.channel.set()

    text = '–û—Ç–ø—Ä–∞–≤—å—Ç–µ @—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª'

    await bot.send_message(call.message.chat.id, text)


@dp.callback_query_handler(lambda call: call.data == 'unsubscribe')
async def unsubscribe_click_inline(call):
    # Set state
    await UnsubscribeForm.channel.set()

    text = '–û—Ç–ø—Ä–∞–≤—å—Ç–µ @—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∫–∞–Ω–∞–ª'

    await bot.send_message(call.message.chat.id, text)


@dp.message_handler(state=SubscribeForm.channel)
async def process_subscribe_channel(message, state):
    user_id = message.from_user.id
    channel = await get_channel(message.text)
    if not channel:
        await bot.send_message(message.chat.id, '–£–∫–∞–∑–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Å—ã–ª–∫–æ–π –Ω–∞ –∫–∞–Ω–∞–ª –∏–ª–∏ @—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º')

    try:
        channel = await bot.get_chat(channel)
    except ChatNotFound:
        await bot.send_message(message.chat.id, '–£–∫–∞–∑–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω')

    async with aiohttp.ClientSession() as session:
        response = await session.get(f'{URL}/api/channel/{channel.id}')
        if response.status == 404:
            data = {"id": channel.id, "title": channel.title, "tags": []}
            response = await session.post(f'{URL}/api/channel/', json=data)
            if response != 201:
                await state.finish()
                return logger.error(await response.text())

        response = await session.get(f'{URL}/api/subscribe/{channel.id}/{user_id}')
        if response.status == 200:
            await state.finish()
            return await bot.send_message(message.chat.id, f"–í—ã —É–∂–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª @{channel.username}")

        data = {"channel_id": channel.id, "user_id": user_id}
        response = await session.post(f'{URL}/api/subscribe/', json=data)
        if response.status != 201:
            await state.finish()
            return logger.error(await response.text())

    await bot.send_message(message.chat.id, f"–í—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @{channel.username}")
    await state.finish()


@dp.message_handler(state=UnsubscribeForm.channel)
async def process_unsubscribe_channel(message, state):
    user_id = message.from_user.id
    channel = await get_channel(message.text)
    if not channel:
        await state.finish()
        return await bot.send_message(message.chat.id, '–£–∫–∞–∑–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Å—ã–ª–∫–æ–π –Ω–∞ –∫–∞–Ω–∞–ª –∏–ª–∏ @—É–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º')

    try:
        channel = await bot.get_chat(channel)
    except ChatNotFound:
        await state.finish()
        return await bot.send_message(message.chat.id, '–£–∫–∞–∑–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω')
    
    async with aiohttp.ClientSession() as session:
        response = await session.delete(f'{URL}/api/subscribe/{channel.id}/{user_id}')
        if response.status == 404:
            await state.finish()
            return bot.send_message(message.chat.id, f"–í—ã –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ –∫–∞–Ω–∞–ª @{channel.username}")
        elif response.status != 204:
            await state.finish()
            return logger.error(await response.text())
    
    await bot.send_message(message.chat.id, f"–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç –∫–∞–Ω–∞–ª–∞ @{channel.username}")
    await state.finish()


async def send_news(user, is_subscribe = False):
    user_id = user['id']

    while True:
        await asyncio.sleep(0)
        if is_subscribe:
            channel = random.choice(user["subscribe_ids"])
        else:
            channel = random.choice(user["channel_ids"])
        channels_dir = path.join(path.dirname(path.abspath(__file__)), "channels_dump")
        channel_file = f"{channel}{random.randint(0, 4)}.json"

        if not os.path.exists(path.join(channels_dir, channel_file)):
            continue

        with open(path.join(channels_dir, channel_file), 'r', encoding='utf-8') as fh:
            data = json.load(fh)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∞—Å—å –ª–∏ –Ω–æ–≤–æ—Å—Ç—å —Ä–∞–Ω—å—à–µ
        if not user_history.get(user_id):
            user_history[user_id] = []

        if data["message_id"] in user_history[user_id]:
            continue
        else:
            async with aiohttp.ClientSession() as session:
                response = await session.get(url=f'{URL}/api/history/{user_id}/{channel}/{data["message_id"]}')
            if response.status == 200:
                user_history[user_id].append(data["message_id"])
                continue

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –Ω–æ–≤–æ—Å—Ç—å —Ñ–∏–ª—å—Ç—Ä—É–µ–º—ã–µ —Å–ª–æ–≤–∞
        if user.get("filter_words"):
            if any(word for word in user["filter_words"] in data["text"]):
                continue

        # –î–æ–±–∞–≤–ª—è–µ–º inline –∫–Ω–æ–ø–∫–∏
        markup = types.InlineKeyboardMarkup(row_width=2)
        markup.add(types.InlineKeyboardButton('‚ù§Ô∏è', callback_data=f'like_{channel}'))
        markup.add(types.InlineKeyboardButton('üëé', callback_data=f'nolike_{channel}'))
        markup.add(types.InlineKeyboardButton('–î–∞–ª–µ–µ', callback_data='next'))

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤–æ—Å—Ç—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        has_file = True if data["filename"] else False
        data = {
            'user_id': user_id,
            'message_id': data['message_id'],
            'channel_id': channel,
            'text': data['text'],
            'has_file': has_file
        }

        async with aiohttp.ClientSession() as session:
            response = await session.post(url=f'{URL}/api/history/', json=data)

        if response.status == 200:
            if not has_file:
                await bot.send_message(user_id, data['text'], reply_markup=markup)
            else:
                if path.join(path.dirname(path.abspath(__file__)), data['filename']).endswith('.mp4'):
                    await bot.send_video(user_id,open(path.join(path.dirname(path.abspath(__file__)), data['filename']), 'rb'), caption=data['text'], reply_markup=markup)           
                else:
                    await bot.send_photo(user_id,open(path.join(path.dirname(path.abspath(__file__)), data['filename']), 'rb'), caption=data['text'], reply_markup=markup)

            user_history[user_id].append(data['message_id'])
            return
        else:
            return logger.error(await response.text())


async def day_news():
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url=f'{URL}/api/users/') as response:
                if response.status == 200:
                    users = await response.json()
                elif response.status == 404:
                    return logger.error("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                else:
                    return logger.error(await response.text())

        for user in users:
            asyncio.ensure_future(send_news(user, is_subscribe=True))
        
        await asyncio.sleep(86400)


async def subscribe_news():
    while True:
        async with aiohttp.ClientSession() as session:
            async with session.get(url=f'{URL}/api/users/') as response:
                if response.status == 200:
                    users = await response.json()
                elif response.status == 404:
                    return logger.error("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                else:
                    return logger.error(await response.text())

        for user in users:
            asyncio.ensure_future(send_news(user, is_subscribe=True))
        
        await asyncio.sleep(10)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    loop.create_task(day_news())
    loop.create_task(subscribe_news())
    executor.start_polling(dp, loop=loop)
